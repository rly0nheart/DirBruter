import sys
import time
import os
import random
import argparse
import aiohttp
import asyncio
from resources.banner import banner
from resources.useragents import user_agents
from resources.colors import red, white, green, blue, yellow, reset

print(banner)


async def fetch(session, url, headers):
    """
    Fetch URL using aiohttp

    :param session: aiohttp ClientSession
    :param url: URL to fetch
    :param headers: Request headers
    :return: Response text and status code as a tuple
    """
    async with session.get(url, headers=headers, timeout=5) as response:
        return await response.text(), response.status


async def dir_bruter(args, wordlist, extensions=None):
    """
    Brute force directories and files.

    :param args: Command-line arguments
    :param wordlist: List of words to brute force
    :param extensions: File extensions to check, defaults to None
    """
    async with aiohttp.ClientSession() as session:
        for word in wordlist:
            word = word.strip()
            # Prepare the list of attempts based on word and extensions
            attempt_list = [f"/{word}/"] if "." not in word else [f"/{word}"]

            if extensions:
                for extension in extensions:
                    attempt_list.append(f"/{word}{extension}")

            for brute in attempt_list:
                target_url = f"{args.url.rstrip('/')}{brute}"
                headers = {"User-Agent": random.choice(user_agents)}
                try:
                    _, status = await fetch(session, target_url, headers)
                    if status == 200:
                        print(f"{white}[{green}FOUND{white}] {status}: {green}{target_url}{reset}")
                        if args.output:
                            save_found_results(target_url)
                    elif args.verbose:
                        if status == 404:
                            print(f"{white}[{red}NOT FOUND{white}] {status}: {red}{target_url}{reset}")
                        else:
                            print(f"{white}[{blue}UNKNOWN{white}] {status}: {blue}{target_url}{reset}")

                except:
                    if args.verbose:
                        print(f"{white}[{yellow}TIMEOUT{white}] Request timed out: {yellow}{target_url}{reset}")


def valid_wordlist(parser, args):
    """
    Validate wordlist file path.

    :param parser: ArgumentParser object
    :param args: Wordlist file path
    :return: List of words from the wordlist
    """
    if not os.path.exists(args):
        print(f"{white}[{red}WARNING{white}] The file {green}{args}{white} does not exist{reset}")
        sys.exit(1)
    else:
        print(f"{white}> Wordlist: {green}{args}{reset}")
        with open(args, 'r') as f:
            return f.readlines()


def save_found_results(target_url):
    """
    Save found results to file.

    :param target_url: URL that was found
    """
    ts = time.localtime()
    timestamp = time.strftime("%H:%M:%S", ts)
    with open('dB_output.txt', 'a') as f:
        f.write(f'[{timestamp}] : {target_url}\n')


def main():
    """Main function to parse arguments and run the brute forcer."""
    # Argument parser setup
    parser = argparse.ArgumentParser(
        description=f'{white}DirBruter â€” by Vijay Sahu | {green}https://github.com/vijaysahuofficial{reset}',
        epilog=f'{white}DirBruter is a Python-based CLI tool that looks for hidden or existing directories/files using the brute force method. It basically works by launching a dictionary-based attack against a webserver and analyzing its response.{reset}')

    parser.add_argument('-t', '--threads', type=int, help='Number of threads (Async so no longer relevant)',
                        default=1)
    parser.add_argument('-u', '--url', type=str, help='Target URL', metavar='<url>', required=True)
    parser.add_argument('-w', '--wordlist', type=lambda x: valid_wordlist(parser, x),
                        help='Path to wordlist', metavar='<wordlist>', required=True)
    parser.add_argument('-o', '--output', help='Save found results to a file', action='store_true')
    parser.add_argument('-v', '--verbose', help='Verbose output (show network logs/errors)', action='store_true')
    parser.add_argument('-e', '--extensions', help='Extensions (example ".php,.exe,.bak")', metavar='<extensions>')

    args = parser.parse_args()
    extensions = args.extensions.split(',') if args.extensions else None

    print(f"{white}> Target: {green}{args.url}{reset}")
    print(f"{white}-{reset}" * 41)

    # Start asynchronous loop
    loop = asyncio.get_event_loop()
    loop.run_until_complete(dir_bruter(args, args.wordlist, extensions))


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"{white}[{red}CTRLC{white}] Exiting...{reset}")
    except Exception as e:
        print(f"{white}[{red}ERROR{white}] An error occurred: {red}{e}{reset}")
